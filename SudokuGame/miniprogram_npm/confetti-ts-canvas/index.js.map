{"version":3,"sources":["index.esm.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/*\r\n    使用代理模式重写Painter，兼容原生Painter\r\n*/\r\nclass Painter {\r\n    constructor(paint) {\r\n        this.paint = null;\r\n        this.paint = paint;\r\n    }\r\n    set fillStyle(style) {\r\n        this.paint.fillStyle = style;\r\n    }\r\n    set lineWidth(width) {\r\n        this.paint.lineWidth = width;\r\n    }\r\n    set strokeStyle(style) {\r\n        this.paint.strokeStyle = style;\r\n    }\r\n    draw() {\r\n        this.paint.draw();\r\n    }\r\n    strokeRect(x, y, w, h) {\r\n        this.paint.strokeRect(x, y, w, h);\r\n    }\r\n    fillRect(x, y, w, h) {\r\n        this.paint.fillRect(x, y, w, h);\r\n    }\r\n    stroke() {\r\n        this.paint.stroke();\r\n    }\r\n    clearRect(x, y, w, h) {\r\n        if (typeof (uni) != 'undefined' && this.paint.draw) {\r\n            this.draw();\r\n        }\r\n        else\r\n            this.paint.clearRect(x, y, w, h);\r\n    }\r\n    save() {\r\n        this.paint.save();\r\n    }\r\n    rotate(angle) {\r\n        this.paint.rotate(angle);\r\n    }\r\n    beginPath() {\r\n        this.paint.beginPath();\r\n    }\r\n    closePath() {\r\n        this.paint.closePath();\r\n    }\r\n    restore() {\r\n        this.paint.restore();\r\n    }\r\n    translate(x, y) {\r\n        this.paint.translate(x, y);\r\n    }\r\n    fill() {\r\n        this.paint.fill();\r\n    }\r\n    arc(x, y, radius, start, end) {\r\n        this.paint.arc(x, y, radius, start, end);\r\n    }\r\n    scale(a, b) {\r\n        this.paint.scale(a, b);\r\n    }\r\n    moveTo(x, y) {\r\n        this.paint.moveTo(x, y);\r\n    }\r\n    lineTo(x, y) {\r\n        this.paint.lineTo(x, y);\r\n    }\r\n    fillText(text, x, y, maxWidth) {\r\n        this.paint.fillText(text, x, y, maxWidth);\r\n    }\r\n    /*清空画布|刷新画布*/\r\n    update() {\r\n    }\r\n}\n\nclass FpsUtil {\r\n    constructor() {\r\n        this.sampleSize = 60;\r\n        this.value = 0;\r\n        this._sample_ = [];\r\n        this._index_ = 0;\r\n        this._lastTick_ = 0;\r\n    }\r\n    tick() {\r\n        let _Date = Date;\r\n        if (typeof (performance) != \"undefined\")\r\n            _Date = performance;\r\n        // if is first tick, just set tick timestamp and return\r\n        if (!this._lastTick_) {\r\n            this._lastTick_ = _Date.now();\r\n            return 0;\r\n        }\r\n        // calculate necessary values to obtain current tick FPS\r\n        let now = _Date.now();\r\n        let delta = (now - this._lastTick_) * 0.001;\r\n        let fps = 1 / delta;\r\n        // add to fps samples, current tick fps value \r\n        this._sample_[this._index_] = fps >> 0;\r\n        // iterate samples to obtain the average\r\n        let average = 0;\r\n        for (let i = 0; i < this._sample_.length; i++)\r\n            average += this._sample_[i];\r\n        average = Math.round(average / this._sample_.length);\r\n        // set new FPS\r\n        this.value = average;\r\n        // store current timestamp\r\n        this._lastTick_ = now;\r\n        // increase sample index counter, and reset it\r\n        // to 0 if exceded maximum sampleSize limit\r\n        this._index_++;\r\n        if (this._index_ === this.sampleSize)\r\n            this._index_ = 0;\r\n        return this.value;\r\n    }\r\n}\n\nclass Size {\r\n    constructor(width, height) {\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    toJson() {\r\n        return {\r\n            width: this.width,\r\n            height: this.height,\r\n        };\r\n    }\r\n    toArray() {\r\n        return [this.width, this.height];\r\n    }\r\n}\n\nvar AnimationState;\r\n(function (AnimationState) {\r\n    AnimationState[AnimationState[\"running\"] = 0] = \"running\";\r\n    AnimationState[AnimationState[\"stop\"] = 1] = \"stop\";\r\n})(AnimationState || (AnimationState = {}));\r\nvar CanvasSize = new Size(0, 0);\r\nvar RenderConfig = {\r\n    grivity: .98,\r\n};\r\nclass CanvasRender {\r\n    constructor() {\r\n        //画布大小\r\n        this.canvasSize = new Size(300, 300);\r\n        //动画状态\r\n        this.animationState = AnimationState.stop;\r\n        //动画完成回调\r\n        this.onFinished = () => { };\r\n        //图形\r\n        this.shapeList = [];\r\n        //渲染器是否被销毁\r\n        this.hasBeenDispose = false;\r\n        //回收栈\r\n        this.revoveryShape = [];\r\n        //FPS工具\r\n        this.fpsUtil = new FpsUtil();\r\n        //显示FPS\r\n        this.displayFPS = false;\r\n    }\r\n    /**\r\n     * @description 初始化渲染器时必须传入 画笔\r\n     * @param paint\r\n     * @param size\r\n     * @param params\r\n     */\r\n    init(paint, size, option) {\r\n        if (paint)\r\n            this.paint = new Painter(paint);\r\n        if (size) {\r\n            this.canvasSize.width = size.width;\r\n            this.canvasSize.height = size.height;\r\n            CanvasSize = this.canvasSize;\r\n        }\r\n        if (option) {\r\n            if (option.onFinished)\r\n                this.onFinished = option.onFinished;\r\n            if (option.displayFps)\r\n                this.displayFPS = option.displayFps;\r\n            RenderConfig.grivity = option.gravity || .30;\r\n        }\r\n    }\r\n    update(animationEngine) {\r\n        if (this.animationState === AnimationState.stop)\r\n            return;\r\n        this.paint.clearRect(0, 0, this.canvasSize.width, this.canvasSize.height);\r\n        if (this.shapeList.length == 0)\r\n            return this.animationFinished();\r\n        const hx = this.canvasSize.width >> 1, hy = this.canvasSize.height >> 1;\r\n        this.shapeList.forEach((shape, ndx) => {\r\n            if (!((shape.position.x < hx && shape.position.x > ~hx) && shape\r\n                .position.y < hy)) {\r\n                shape.disable();\r\n            }\r\n            shape.update(this.paint);\r\n        });\r\n        //回收对象\r\n        this.recovery();\r\n        //渲染FPS\r\n        if (this.displayFPS) {\r\n            const fps = this.fpsUtil.tick();\r\n            this.paint.fillStyle = \"black\";\r\n            this.paint.fillText(\"FPS:\" + fps, 10, 20);\r\n        }\r\n        animationEngine(() => {\r\n            this.update(animationEngine);\r\n        });\r\n    }\r\n    animationFinished() {\r\n        var _a;\r\n        this.animationState = AnimationState.stop;\r\n        (_a = this.onFinished) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    }\r\n    /**\r\n      * @description 回收彩纸对象\r\n      */\r\n    recovery() {\r\n        this.shapeList = this.shapeList.filter((item, ndx) => {\r\n            if (!item.alive) {\r\n                this.revoveryShape.push(item);\r\n            }\r\n            return item.alive;\r\n        });\r\n    }\r\n    /**\r\n     * @description 在回收栈里面拿重复利用对象\r\n     * @param {number} count //拿多少个\r\n     */\r\n    recover(count) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.hasBeenDispose) {\r\n                throw new Error('This CanvasRender has been destroyed!');\r\n            }\r\n            const len = this.revoveryShape.length;\r\n            if (count > len) {\r\n                const re = [];\r\n                for (let i = 0; i < len; i++) {\r\n                    re.push(this.revoveryShape.pop());\r\n                }\r\n                return Promise.resolve(re);\r\n            }\r\n            else {\r\n                const re = [];\r\n                for (let i = 0; i < count; i++) {\r\n                    re.push(this.revoveryShape.pop());\r\n                }\r\n                return Promise.resolve(re);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @description 销毁渲染器，释放所有内存，无法再继续使用\r\n     * @returns void\r\n     */\r\n    dispose() {\r\n        if (this.hasBeenDispose)\r\n            return;\r\n        this.hasBeenDispose = true;\r\n        this.animationState = AnimationState.stop;\r\n        this.paint.clearRect(0, 0, this.canvasSize.width, this.canvasSize.height);\r\n        this.paint = this.shapeList = this.revoveryShape = this.fpsUtil = null;\r\n    }\r\n    /**\r\n     * @description 运行\r\n     * @returns\r\n     */\r\n    run() {\r\n        if (this.hasBeenDispose) {\r\n            return console.error(\"CanvasRender has been destroyed!\");\r\n        }\r\n        let animationEngine = function (callback) {\r\n            setTimeout(callback, 1000 / 60);\r\n        };\r\n        if (typeof (requestIdleCallback) != \"undefined\") {\r\n            animationEngine = requestAnimationFrame;\r\n        }\r\n        animationEngine(() => {\r\n            if (this.shapeList.length != 0)\r\n                this.update(animationEngine);\r\n        });\r\n    }\r\n    add(shapes) {\r\n        /*fire的时候继续开启动画状态*/\r\n        if (this.animationState == AnimationState.stop) {\r\n            this.animationState = AnimationState.running;\r\n            this.run();\r\n        }\r\n        this.shapeList.push(...shapes);\r\n    }\r\n}\n\n/*矩阵工具类*/\r\nclass Matrix3 {\r\n    static transformTo2D(point, A, position) {\r\n        return {\r\n            x: (CanvasSize.width * .5) + position.x + point.x,\r\n            y: (CanvasSize.height * .5) + position.y + point.y //+y,\r\n        };\r\n    }\r\n    static rotateX(point, angle) {\r\n        //const mp = point.toArray();\r\n        const cos_ = Math.cos(angle), sin_ = Math.sin(angle);\r\n        const y = point.y * cos_ - point.z * sin_;\r\n        const z = point.z * cos_ + point.y * sin_;\r\n        const result = [point.x, y, z];\r\n        // const mf = [\r\n        // \t[1, 0, 0],\r\n        // \t[0, cos_, (sin_*-1)],\r\n        // \t[0, sin_, cos_]\r\n        // ];\r\n        return result;\r\n    }\r\n    static rotateZ(point, angle) {\r\n        //const mp = point.toArray();\r\n        const cos_ = Math.cos(angle), sin_ = Math.sin(angle);\r\n        const x = point.x * cos_ - point.y * sin_;\r\n        const y = point.x * sin_ + point.y * cos_;\r\n        return [x, y, point.z];\r\n        // const mf = [\r\n        // \t[cos_, (sin_*-1) , 0],\r\n        // \t[sin_, cos_, 0],\r\n        // \t[0, 0, 1]\r\n        // ];\r\n    }\r\n    static rotateY(point, angle) {\r\n        const cos_ = Math.cos(angle), sin_ = Math.sin(angle);\r\n        const x = point.x * cos_ - point.z * sin_;\r\n        const z = point.z * cos_ + point.x * sin_;\r\n        return [x, point.y, z];\r\n    }\r\n}\r\nclass Matrix3All {\r\n    static rotateX(shape, angle) {\r\n        shape.points.forEach((item) => {\r\n            const newPoint = Matrix3.rotateX(item, Matrix3All.PI * angle);\r\n            item.setPoint(newPoint);\r\n        });\r\n    }\r\n    static rotateY(shape, angle) {\r\n        shape.points.forEach((item) => {\r\n            const newPoint = Matrix3.rotateY(item, Matrix3All.PI * angle);\r\n            item.setPoint(newPoint);\r\n        });\r\n    }\r\n    static rotateZ(shape, angle) {\r\n        shape.points.forEach((item) => {\r\n            const newPoint = Matrix3.rotateZ(item, Matrix3All.PI * angle);\r\n            item.setPoint(newPoint);\r\n        });\r\n    }\r\n}\r\nMatrix3All.PI = Math.PI / 180;\n\nclass Vector {\r\n    constructor(x, y) {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n    }\r\n    sub(v) {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        return this;\r\n    }\r\n    mult(v) {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        return this;\r\n    }\r\n    div(v) {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        return this;\r\n    }\r\n    mag() {\r\n        return Math.sqrt(this.x * this.x + this.y * this.y);\r\n    }\r\n    dist(v) {\r\n        let dx = this.x - v.x;\r\n        let dy = this.y - v.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    normalize() {\r\n        let len = this.mag();\r\n        this.x /= len;\r\n        this.y /= len;\r\n        return this;\r\n    }\r\n    clamp(c) {\r\n        let [max, min] = c;\r\n        this.x = Math.min(Math.max(this.x, min), max);\r\n        this.y = Math.min(Math.max(this.y, min), max);\r\n    }\r\n    copy() {\r\n        return new Vector(this.x, this.y);\r\n    }\r\n    set(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n    }\r\n    setXY(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    toJson() {\r\n        return {\r\n            x: this.x,\r\n            y: this.y,\r\n        };\r\n    }\r\n    toArray() {\r\n        return [this.x, this.y];\r\n    }\r\n    static dist(v1, v2) {\r\n        let sub = Vector.sub(v1, v2);\r\n        return Vector.mag(sub);\r\n    }\r\n    static mag(v) {\r\n        return Math.sqrt(v.x * v.x + v.y * v.y);\r\n    }\r\n    static sub(v1, v2) {\r\n        return new Vector(v1.x - v2.x, v1.y - v2.y);\r\n    }\r\n}\n\nclass Point extends Vector {\r\n    constructor(x, y) {\r\n        super(x, y);\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.z = 0;\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    setPoint(point) {\r\n        const [x, y, z] = point;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    toArray() {\r\n        return [this.x, this.y];\r\n    }\r\n}\r\n/**\r\n * 纸屑类基类\r\n */\r\nclass Shape {\r\n    constructor() {\r\n        this.points = [];\r\n        this.position = new Vector(0, 0);\r\n        this.vector = new Vector(0, 0);\r\n        this._alive = true;\r\n        this.gravity = RenderConfig.grivity;\r\n    }\r\n    get alive() {\r\n        return this._alive;\r\n    }\r\n    relive() {\r\n        this._alive = true;\r\n    }\r\n    disable() {\r\n        this._alive = false;\r\n    }\r\n    update(paint) {\r\n        this.move();\r\n        this.material.update(paint, this.position, this);\r\n        const speed = 20;\r\n        const ran = () => Math.random() * speed;\r\n        Matrix3All.rotateX(this, ran() - this.vector.y);\r\n        Matrix3All.rotateY(this, ran() - this.vector.x);\r\n        Matrix3All.rotateZ(this, ran() - this.vector.y);\r\n    }\r\n    move() {\r\n        if (Math.abs(this.vector.x) > .2)\r\n            this.vector.x *= .9;\r\n        if (Math.abs(this.vector.y) > 1)\r\n            this.vector.y *= .9;\r\n        this.vector.y += this.gravity;\r\n        this.vector.x += Math.random() > .5 ? -.2 : .2;\r\n        this.position.add(this.vector);\r\n    }\r\n    reset(reset) {\r\n        this.relive();\r\n        this.material.opacity = 1;\r\n        this.position.setXY(reset.position.x, reset.position.y);\r\n        this.vector.setXY(reset.vector.x, reset.vector.y);\r\n    }\r\n}\n\nclass Material {\r\n    constructor(points) {\r\n        this.A = new Point(0, 0);\r\n        this.points = [];\r\n        this.opacity = 1;\r\n        this.points = points;\r\n        const colorAndKey = Styles.RandomColor;\r\n        this._color = colorAndKey.color;\r\n        this._color_key = colorAndKey.key;\r\n    }\r\n    update(paint, position, shape) {\r\n        if (this.opacity <= .05) {\r\n            return shape.disable();\r\n        }\r\n        this.opacity -= .004;\r\n        this.draw(paint, position);\r\n    }\r\n    draw(paint, position) {\r\n        //paint.fillRect(position.x,position.y,10,10)\r\n        paint.beginPath();\r\n        //if(!this._color)return;\r\n        this._color[3] = this.opacity;\r\n        /*判断上次颜色是否和这次一样*/\r\n        paint.fillStyle = Styles.rgba(this._color);\r\n        this.points.forEach((point) => {\r\n            const dp = Matrix3.transformTo2D(point, this.A, position);\r\n            paint.lineTo(dp.x, dp.y);\r\n        });\r\n        paint.closePath();\r\n        paint.fill();\r\n    }\r\n}\r\nclass Styles {\r\n    /**\r\n     * @param {Array<String|Array>} colors\r\n     * @description 自定义颜色转换\r\n     */\r\n    static setColors(colors) {\r\n        if (colors.length == 0)\r\n            return;\r\n        Styles._colors = [];\r\n        colors.forEach((item) => {\r\n            if (item instanceof Array) {\r\n                Styles._colors.push(item);\r\n            }\r\n            else if (typeof (item) === 'string') {\r\n                Styles._colors.push(ColorUtil.transformHexToRGB(item));\r\n            }\r\n        });\r\n    }\r\n    static get RandomColor() {\r\n        const colors = Styles._colors;\r\n        const ran = (Math.random() * colors.length) >> 0;\r\n        const color = colors[ran];\r\n        return {\r\n            key: ran,\r\n            color: [...color],\r\n        };\r\n    }\r\n    static rgba(color) {\r\n        const [r, g, b, a] = color;\r\n        return `rgba(${r},${g},${b},${a})`;\r\n    }\r\n}\r\nStyles._colors = [\r\n    [253, 101, 255],\r\n    [163, 253, 130],\r\n    [183, 128, 253],\r\n    [89, 214, 255],\r\n    [253, 186, 96],\r\n    [251, 253, 113],\r\n];\r\nclass ColorUtil {\r\n    /**\r\n     * @param {Sting} hex\r\n     * @description 将十六进制转换成rgb数组形式\r\n     */\r\n    static transformHexToRGB(hex) {\r\n        const len = hex.length;\r\n        let newHex = hex;\r\n        /*不足六位补齐*/\r\n        if (len < 6) {\r\n            for (let i = 0; i < 6 - len; i++) {\r\n                newHex += \"0\";\r\n            }\r\n        }\r\n        const rgbArr = [];\r\n        for (let i = 0; i <= 2; i++) {\r\n            const hex_2 = newHex.substr(i * 2, 2);\r\n            rgbArr[i] = parseInt(hex_2, 16);\r\n        }\r\n        return rgbArr;\r\n    }\r\n}\n\nclass CustomShape extends Shape {\r\n    constructor(params) {\r\n        super();\r\n        this._originPoints = [];\r\n        this.scale = 1;\r\n        this._originPoints = params.points;\r\n        this.scale = params.scale || 1;\r\n        this.createPosints(params.points);\r\n        this.material = new Material(this.points);\r\n        if (params.position)\r\n            this.position = params.position;\r\n        if (params.vector)\r\n            this.vector = params.vector;\r\n    }\r\n    get originPoints() {\r\n        return this._originPoints;\r\n    }\r\n    createPosints(points = []) {\r\n        const len = points.length;\r\n        for (let i = 0; i < len; i++) {\r\n            let [x, y] = points[i];\r\n            if (this.scale != 1) {\r\n                x *= this.scale;\r\n                y *= this.scale;\r\n            }\r\n            this.points.push(new Point(x, y));\r\n        }\r\n    }\r\n}\n\nclass Polygon extends Shape {\r\n    constructor(params) {\r\n        super();\r\n        this.size = params.size;\r\n        this.createPosints(params.count);\r\n        this.material = new Material(this.points);\r\n        this.vector = params.vector;\r\n        this.position = params.position;\r\n    }\r\n    createPosints(count) {\r\n        const PI = Math.PI * 2;\r\n        const half_w = this.size.width >> 1;\r\n        const avg = PI / count;\r\n        for (let i = 0; i < count; i++) {\r\n            const point = new Point(Math.cos(i * avg) * half_w, Math.sin(i * avg) * half_w);\r\n            this.points.push(point);\r\n        }\r\n    }\r\n}\n\nclass Utils {\r\n    static constructorIs(obj, constructorName) {\r\n        if ((typeof obj) == 'object') {\r\n            return obj.constructor.name === constructorName;\r\n        }\r\n        return false;\r\n    }\r\n}\n\n/*形状类型枚举*/\r\nclass ConfettiShapes {\r\n}\r\nConfettiShapes.POLYGON = 'Polygon';\r\nConfettiShapes.CUSTOM = 'CustomShape';\r\n/*喷发类*/\r\nclass ConfettiEjector {\r\n    constructor(canvasRender, params) {\r\n        /*彩纸片边角数量集合*/\r\n        this.shapeTypes = [3, 4, 15];\r\n        this.PI = Math.PI / 180;\r\n        /*每次爆炸彩纸数量*/\r\n        this.count = 30;\r\n        //限制喷射角度，顺时针\r\n        this.limitAngle = [90, 270];\r\n        const { limitAngle, count, shapeTypes, colors } = params || {};\r\n        if (canvasRender == undefined) {\r\n            console.error(\"CanvasRender不能为空\");\r\n            return;\r\n        }\r\n        this.canvasRender = canvasRender;\r\n        this.limitAngle = limitAngle || [0, 360];\r\n        this.count = count || 30;\r\n        this.shapeTypes = shapeTypes || [3, 4, 5, 6, 15];\r\n        if (colors) {\r\n            Styles.setColors(colors);\r\n        }\r\n    }\r\n    /*获取指定区间值*/\r\n    getRandomClamp([min, max]) {\r\n        const ran = Math.random() * (max - min + 1) + min;\r\n        return ran;\r\n    }\r\n    create(params) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { x, y, clampforce, radius } = params;\r\n            //喷射速度\r\n            const spraySpeed = clampforce || [20, 40];\r\n            const shapesCache = [];\r\n            /*重新使用被回收的对象*/\r\n            const recover = yield this.canvasRender.recover(this.count);\r\n            const len = recover.length;\r\n            for (let i = 0; i < len; i++) {\r\n                const shape = recover[i];\r\n                const ranAngle = this.getRandomClamp(this.limitAngle) * this.PI;\r\n                const speed = this.getRandomClamp(spraySpeed);\r\n                const vx = Math.cos(ranAngle) * speed;\r\n                const vy = Math.sin(ranAngle) * speed;\r\n                shape.reset({\r\n                    position: new Vector(x, y),\r\n                    vector: new Vector(vx, vy)\r\n                });\r\n            }\r\n            shapesCache.push(...recover);\r\n            for (let i = 0; i < this.count - len; i++) {\r\n                const shapeType = this.shapeTypes[(Math.random() * this.shapeTypes.length) >> 0];\r\n                const ranAngle = this.getRandomClamp(this.limitAngle) * this.PI;\r\n                const speed = this.getRandomClamp(spraySpeed);\r\n                const vx = Math.cos(ranAngle) * speed;\r\n                const vy = Math.sin(ranAngle) * speed;\r\n                if (Utils.constructorIs(shapeType, ConfettiShapes.CUSTOM)) {\r\n                    const _ = shapeType;\r\n                    const originCustomShape = _;\r\n                    const customShape = new CustomShape({\r\n                        points: originCustomShape.originPoints,\r\n                        position: new Vector(x, y),\r\n                        vector: new Vector(vx, vy),\r\n                        scale: originCustomShape.scale,\r\n                    });\r\n                    shapesCache.push(customShape);\r\n                    continue;\r\n                }\r\n                const _ = shapeType;\r\n                const count = _;\r\n                const shape = new Polygon({\r\n                    size: new Size(radius, radius),\r\n                    count: count,\r\n                    position: new Vector(x, y),\r\n                    vector: new Vector(vx, vy),\r\n                });\r\n                shapesCache.push(shape);\r\n            }\r\n            return Promise.resolve(shapesCache);\r\n        });\r\n    }\r\n    fire(_shapes) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const shapes = yield _shapes;\r\n            this.canvasRender.add(shapes);\r\n        });\r\n    }\r\n}\n\nclass Confetti {\r\n    constructor(options) {\r\n        this.render = new CanvasRender();\r\n        const { paint, canvasWidth, canvasHeight, displayFps = false } = options;\r\n        this.render.init(paint, {\r\n            width: canvasWidth,\r\n            height: canvasHeight,\r\n        }, {\r\n            displayFps: displayFps,\r\n            onFinished: () => {\r\n                this.render.dispose();\r\n            }\r\n        });\r\n    }\r\n    run(options) {\r\n        const { shapeTypes = [3, 4, 5, 10], x = 0, y = 0, radius = 10, clampforce = [30, 90], count = 90 } = options !== null && options !== void 0 ? options : {};\r\n        const pao = new ConfettiEjector(this.render, { count: count, limitAngle: [225, 310], shapeTypes: shapeTypes });\r\n        const boom = pao.create({ x: x, y: y, radius: radius, clampforce: clampforce });\r\n        pao.fire(boom);\r\n    }\r\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'CanvasRender', { enumerable: true, configurable: true, get: function() { return CanvasRender; } });Object.defineProperty(exports, 'CanvasSize', { enumerable: true, configurable: true, get: function() { return CanvasSize; } });Object.defineProperty(exports, 'Confetti', { enumerable: true, configurable: true, get: function() { return Confetti; } });Object.defineProperty(exports, 'ConfettiEjector', { enumerable: true, configurable: true, get: function() { return ConfettiEjector; } });Object.defineProperty(exports, 'CustomShape', { enumerable: true, configurable: true, get: function() { return CustomShape; } });Object.defineProperty(exports, 'Polygon', { enumerable: true, configurable: true, get: function() { return Polygon; } });\n"]}